<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VDC Terrain Export Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f9fafb;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px 30px;
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .header h1 { font-size: 24px; margin-bottom: 5px; }
        .header p { font-size: 14px; opacity: 0.9; }
        .main { flex: 1; display: flex; overflow: hidden; }
        .sidebar {
            width: 350px;
            background: white;
            border-right: 1px solid #e5e7eb;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .tabs {
            display: flex;
            background: #f9fafb;
            border-bottom: 2px solid #e5e7eb;
        }
        .tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            color: #6b7280;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }
        .tab:hover { background: #f3f4f6; }
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: white;
        }
        .tab-content { display: none; padding: 24px; flex: 1; }
        .tab-content.active { display: flex; flex-direction: column; }
        .control-group { margin-bottom: 20px; }
        .control-group label {
            display: block;
            font-weight: 600;
            font-size: 14px;
            color: #374151;
            margin-bottom: 8px;
        }
        .control-group input[type="text"],
        .control-group input[type="number"],
        .control-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
        }
        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .hint {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
            line-height: 1.4;
        }
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #667eea;
            color: white;
        }
        .btn-primary:hover:not(:disabled) { background: #5568d3; }
        .btn-primary:disabled {
            background: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            margin-top: 8px;
        }
        .btn-secondary:hover:not(:disabled) { background: #e5e7eb; }
        .message {
            margin-top: 16px;
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.4;
        }
        .message.success {
            background: #ecfdf5;
            color: #065f46;
            border: 1px solid #10b981;
        }
        .message.error {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }
        .message.info {
            background: #eff6ff;
            color: #1e40af;
            border: 1px solid #3b82f6;
        }
        #map { flex: 1; }
        #viewer3d {
            flex: 1;
            background: linear-gradient(to bottom, #87ceeb 0%, #f0f0f0 100%);
            position: relative;
        }
        .info-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.95);
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 300px;
            z-index: 10;
        }
        .info-overlay h3 {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }
        .info-overlay p {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
        }
        .export-section {
            background: #f9fafb;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        .export-section h4 {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
        }
        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .export-btn {
            padding: 10px;
            font-size: 12px;
        }
        .terrain-info {
            background: #f9fafb;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        .terrain-info-item {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e5e7eb;
        }
        .terrain-info-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .terrain-info-label {
            color: #6b7280;
            font-weight: 500;
        }
        .terrain-info-value {
            color: #374151;
            font-weight: 600;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            margin-bottom: 12px;
        }
        .checkbox-label input {
            width: 18px;
            height: 18px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üèîÔ∏è VDC Terrain Export Tool - Professional Survey Grade</h1>
        <p>Import USGS terrain and ULTRA HD satellite imagery for SketchUp/Civil3D | 8192√ó8192 textures | 2048√ó2048 elevation</p>
    </div>

    <div class="main">
        <div class="sidebar">
            <div class="tabs">
                <div class="tab active" data-tab="import">Import</div>
                <div class="tab" data-tab="view">3D View</div>
                <div class="tab" data-tab="export">Export</div>
            </div>

            <!-- IMPORT TAB -->
            <div class="tab-content active" data-content="import">
                <div style="background: #ecfdf5; border: 1px solid #10b981; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <p style="font-size: 13px; color: #065f46; line-height: 1.5;">
                        ‚úÖ <strong>USGS 3DEP + ULTRA HD Satellite Imagery</strong><br>
                        No API key required! 8192√ó8192 professional-grade aerial photos.<br>
                        <small style="opacity: 0.8;">2048√ó2048 elevation grid | Zoom level 21 imagery</small>
                    </p>
                </div>

                <div class="control-group">
                    <label>State Plane Zone</label>
                    <select id="statePlane">
                        <option value="2276">Texas Central (EPSG:2276)</option>
                        <option value="2277" selected>Texas North Central (EPSG:2277)</option>
                        <option value="2278">Texas North (EPSG:2278)</option>
                        <option value="2279">Texas South Central (EPSG:2279)</option>
                        <option value="2280">Texas South (EPSG:2280)</option>
                    </select>
                    <p class="hint">NAD83 US Survey Feet coordinates</p>
                </div>

                <button class="btn btn-primary" id="importBtn" disabled>
                    üì• Import Terrain + Imagery
                </button>

                <div id="importMessage"></div>

                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e5e7eb;">
                    <p style="font-size: 12px; color: #6b7280; line-height: 1.6;">
                        <strong>How to use:</strong><br>
                        1. Pan/zoom the map to your location<br>
                        2. Click and drag to select area<br>
                        3. Click Import<br>
                        4. View in 3D and export with imagery
                    </p>
                </div>
            </div>

            <!-- 3D VIEW TAB -->
            <div class="tab-content" data-content="view">
                <div id="terrainStats"></div>

                <button class="btn btn-secondary" id="resetCameraBtn" disabled>
                    üéØ Reset Camera / Zoom to Fit
                </button>

                <div class="control-group" style="margin-top: 20px;">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableVExag">
                        <span>Enable Vertical Exaggeration</span>
                    </label>
                    <p class="hint">Amplify or reduce terrain height for visualization</p>
                </div>

                <div class="control-group" id="vExagControls" style="opacity: 0.5; pointer-events: none;">
                    <label>Scale Factor</label>
                    <input type="range" id="vExag" min="0.3" max="3" step="0.1" value="1" disabled>
                    <p class="hint">Current: <span id="vExagValue">1.0</span>x (Default: 1:1 scale)</p>
                </div>

                <div id="viewMessage"></div>

                <div style="margin-top: auto; padding-top: 20px;">
                    <p style="font-size: 12px; color: #6b7280;">
                        <strong>3D Controls:</strong><br>
                        ‚Ä¢ Left drag: Rotate view<br>
                        ‚Ä¢ Right drag: Pan<br>
                        ‚Ä¢ Scroll: Zoom in/out
                    </p>
                </div>
            </div>

            <!-- EXPORT TAB -->
            <div class="tab-content" data-content="export">
                <div class="export-section">
                    <h4>üì¶ For SketchUp (Y-forward, Z-up)</h4>
                    <label class="checkbox-label">
                        <input type="checkbox" id="includeImageryOBJ" checked>
                        <span>Include satellite imagery texture</span>
                    </label>
                    <div class="export-buttons">
                        <button class="btn btn-secondary export-btn" id="exportOBJ" disabled>
                            OBJ + MTL
                        </button>
                        <button class="btn btn-secondary export-btn" id="exportFBX" disabled>
                            FBX (Embedded)
                        </button>
                    </div>
                </div>

                <div class="export-section">
                    <h4>üìê For Civil 3D</h4>
                    <div class="export-buttons">
                        <button class="btn btn-secondary export-btn" id="exportDXF" disabled>
                            DXF Contours
                        </button>
                        <button class="btn btn-secondary export-btn" id="exportCSV" disabled>
                            CSV Points
                        </button>
                    </div>
                </div>

                <div class="export-section">
                    <h4>üó∫Ô∏è GIS Data</h4>
                    <div class="export-buttons">
                        <button class="btn btn-secondary export-btn" id="exportGeoTIFF" disabled>
                            GeoTIFF DEM
                        </button>
                        <button class="btn btn-secondary export-btn" id="exportJSON" disabled>
                            GeoJSON
                        </button>
                    </div>
                </div>

                <div id="exportMessage"></div>

                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e5e7eb;">
                    <p style="font-size: 12px; color: #6b7280; line-height: 1.6;">
                        <strong>Export Notes:</strong><br>
                        ‚Ä¢ OBJ/FBX use Y-forward, Z-up (SketchUp standard)<br>
                        ‚Ä¢ ULTRA HD satellite imagery (8192√ó8192 texture)<br>
                        ‚Ä¢ Maximum resolution elevation data (2048√ó2048 grid)<br>
                        ‚Ä¢ Vertical exaggeration applied if enabled<br>
                        ‚Ä¢ State Plane NAD83 coordinates<br>
                        ‚Ä¢ Professional survey-grade quality
                    </p>
                </div>
            </div>
        </div>

        <div style="flex: 1; display: flex; flex-direction: column;">
            <div id="map" style="flex: 1;"></div>
            <div id="viewer3d" style="flex: 1; display: none;">
                <div class="info-overlay" id="viewer3dInfo">
                    <h3>üèîÔ∏è 3D Terrain Viewer</h3>
                    <p style="color: #6b7280;">Import terrain to begin</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let map, rectangle = null, bounds = null;
        let terrainData = null;
        let imageryBlob = null;
        let scene, camera, renderer, terrainMesh;

        // Initialize map
        map = L.map('map').setView([30.2672, -97.7431], 10); // Cedar Park, TX
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap'
        }).addTo(map);

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabName = this.dataset.tab;
                
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.querySelector(`[data-content="${tabName}"]`).classList.add('active');
                
                if (tabName === 'view') {
                    document.getElementById('map').style.display = 'none';
                    document.getElementById('viewer3d').style.display = 'block';
                    if (terrainData && !scene) {
                        setTimeout(() => init3DViewer(), 100);
                    }
                } else {
                    document.getElementById('map').style.display = 'block';
                    document.getElementById('viewer3d').style.display = 'none';
                }
            });
        });

        // Map drawing
        let isDrawing = false, startPoint = null;
        
        map.on('mousedown', e => {
            isDrawing = true;
            startPoint = e.latlng;
            if (rectangle) map.removeLayer(rectangle);
        });
        
        map.on('mousemove', e => {
            if (!isDrawing || !startPoint) return;
            const newBounds = L.latLngBounds(startPoint, e.latlng);
            if (rectangle) map.removeLayer(rectangle);
            rectangle = L.rectangle(newBounds, {
                color: '#667eea',
                weight: 2,
                fillOpacity: 0.1
            }).addTo(map);
        });
        
        map.on('mouseup', e => {
            if (!isDrawing) return;
            isDrawing = false;
            if (startPoint) {
                bounds = L.latLngBounds(startPoint, e.latlng);
                if (rectangle) map.removeLayer(rectangle);
                rectangle = L.rectangle(bounds, {
                    color: '#667eea',
                    weight: 2,
                    fillOpacity: 0.1
                }).addTo(map);
                document.getElementById('importBtn').disabled = false;
            }
        });

        // Import terrain
        document.getElementById('importBtn').addEventListener('click', async function() {
            const messageDiv = document.getElementById('importMessage');
            
            this.disabled = true;
            messageDiv.innerHTML = '<div class="message info">üì° Fetching terrain + satellite imagery from USGS...</div>';

            const south = bounds.getSouth();
            const north = bounds.getNorth();
            const west = bounds.getWest();
            const east = bounds.getEast();

            try {
                await importFromUSGS(south, north, west, east, messageDiv);
                
                document.querySelectorAll('.export-btn').forEach(btn => btn.disabled = false);
                document.getElementById('resetCameraBtn').disabled = false;
                
                updateTerrainStats();
                
            } catch (error) {
                messageDiv.innerHTML = `<div class="message error">‚ùå ${error.message}</div>`;
            } finally {
                this.disabled = false;
            }
        });

        async function importFromUSGS(south, north, west, east, messageDiv) {
            console.log('=== IMPORTING MAXIMUM QUALITY TERRAIN FROM USGS 3DEP ===');
            
            messageDiv.innerHTML = '<div class="message info">üì° Downloading HIGH RESOLUTION elevation data...</div>';
            
            const bbox = `${west},${south},${east},${north}`;
            
            // MAXIMUM RESOLUTION - 4096x4096 for professional-grade terrain
            const imgSize = 2048; // Increased from 128 to 2048 (16x more detail)
            
            const params = new URLSearchParams({
                bbox: bbox,
                bboxSR: '4326',
                size: `${imgSize},${imgSize}`,
                imageSR: '4326',
                format: 'tiff',
                pixelType: 'F32',
                noData: '-9999',
                interpolation: 'RSP_BilinearInterpolation',
                f: 'image'
            });

            const url = `https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/exportImage?${params}`;
            
            console.log(`Requesting ${imgSize}x${imgSize} elevation grid (ultra high resolution)`);
            
            const response = await fetch(url);
            if (!response.ok) throw new Error(`USGS API returned ${response.status}`);
            
            const arrayBuffer = await response.arrayBuffer();
            console.log('Downloaded', (arrayBuffer.byteLength / 1024 / 1024).toFixed(2), 'MB elevation data');
            
            messageDiv.innerHTML = '<div class="message info">üîÑ Processing high-resolution elevation data...</div>';
            
            const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
            const image = await tiff.getImage();
            const rasters = await image.readRasters();
            const elevationData = rasters[0];
            
            const width = image.getWidth();
            const height = image.getHeight();
            
            console.log(`Elevation grid: ${width}x${height} points = ${(width * height).toLocaleString()} elevation samples`);
            
            terrainData = {
                bounds: {south, north, west, east},
                resolution: Math.min(width, height),
                grid: [],
                statePlane: document.getElementById('statePlane').value,
                minElevation: Infinity,
                maxElevation: -Infinity,
                source: 'USGS 3DEP (Maximum Resolution)'
            };
            
            for (let i = 0; i < height; i++) {
                const row = [];
                for (let j = 0; j < width; j++) {
                    const idx = i * width + j;
                    let elevation = elevationData[idx];
                    
                    if (elevation === -9999 || elevation < -500 || elevation > 30000) {
                        elevation = 1000;
                    }
                    
                    elevation = elevation * 3.28084; // meters to feet
                    row.push(elevation);
                    
                    if (elevation < terrainData.minElevation) terrainData.minElevation = elevation;
                    if (elevation > terrainData.maxElevation) terrainData.maxElevation = elevation;
                }
                terrainData.grid.push(row);
            }
            
            // Fetch satellite imagery
            messageDiv.innerHTML = '<div class="message info">üõ∞Ô∏è Downloading ULTRA HIGH RESOLUTION satellite imagery...</div>';
            await fetchSatelliteImagery(south, north, west, east);
            
            messageDiv.innerHTML = `<div class="message success">‚úÖ MAXIMUM QUALITY terrain + imagery imported!<br>
                <small>Elevation: ${terrainData.minElevation.toFixed(0)}' - ${terrainData.maxElevation.toFixed(0)}' | ${(width * height).toLocaleString()} elevation points</small>
            </div>`;
        }

        async function fetchSatelliteImagery(south, north, west, east) {
            console.log('=== FETCHING ULTRA HIGH RESOLUTION SATELLITE IMAGERY ===');
            
            // Calculate optimal zoom level based on bounds
            const latDiff = north - south;
            const lonDiff = east - west;
            const maxDiff = Math.max(latDiff, lonDiff);
            
            // MAXIMUM ZOOM LEVELS for highest detail (20-21 is maximum for most services)
            let zoom = 21; // MAXIMUM detail available
            if (maxDiff > 0.002) zoom = 20;
            if (maxDiff > 0.005) zoom = 19;
            if (maxDiff > 0.01) zoom = 18;
            if (maxDiff > 0.02) zoom = 17;
            if (maxDiff > 0.05) zoom = 16;
            if (maxDiff > 0.1) zoom = 15;
            if (maxDiff > 0.2) zoom = 14;
            if (maxDiff > 0.5) zoom = 13;
            
            console.log(`üéØ Using MAXIMUM zoom level ${zoom} for area ${maxDiff.toFixed(6)}¬∞`);
            
            // Convert lat/lon to tile coordinates
            const getTileCoords = (lat, lon, z) => {
                const x = Math.floor((lon + 180) / 360 * Math.pow(2, z));
                const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 
                    1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, z));
                return { x, y };
            };
            
            const nwTile = getTileCoords(north, west, zoom);
            const seTile = getTileCoords(south, east, zoom);
            
            // Calculate tiles needed
            const tilesX = Math.abs(seTile.x - nwTile.x) + 1;
            const tilesY = Math.abs(seTile.y - nwTile.y) + 1;
            const totalTiles = tilesX * tilesY;
            
            console.log(`üì• Loading ${tilesX}x${tilesY} = ${totalTiles} tiles at zoom ${zoom}`);
            
            // ULTRA HIGH RESOLUTION TEXTURE - 8192x8192 for professional-grade imagery
            const tileSize = 256;
            const canvasWidth = 8192;  // DOUBLED from 4096 - PROFESSIONAL SURVEY GRADE
            const canvasHeight = 8192;
            
            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext('2d', { 
                alpha: false,
                desynchronized: true,
                willReadFrequently: false
            });
            
            // MAXIMUM QUALITY rendering settings
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Fill with base color in case tiles fail
            ctx.fillStyle = '#7cb342';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Load and composite tiles with proper ordering
            const tilePromises = [];
            
            // Try multiple imagery sources for best quality
            const imageSources = [
                // ESRI World Imagery (primary - highest quality)
                (z, y, x) => `https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/${z}/${y}/${x}`,
                // Bing aerial imagery (fallback)
                (z, y, x) => {
                    const quadkey = tileToQuadKey(x, y, z);
                    return `https://t0.ssl.ak.dynamic.tiles.virtualearth.net/comp/ch/${quadkey}?mkt=en-US&it=A,G,L&shading=hill`;
                }
            ];
            
            for (let ty = 0; ty < tilesY; ty++) {
                for (let tx = 0; tx < tilesX; tx++) {
                    const tileX = nwTile.x + tx;
                    const tileY = nwTile.y + ty;
                    
                    // Try ESRI first (best quality)
                    const url = imageSources[0](zoom, tileY, tileX);
                    
                    const promise = loadTileImage(url).then(img => {
                        if (img) {
                            // Calculate position in composite canvas with sub-pixel precision
                            const destX = (tx / tilesX) * canvasWidth;
                            const destY = (ty / tilesY) * canvasHeight;
                            const destW = canvasWidth / tilesX;
                            const destH = canvasHeight / tilesY;
                            
                            // Draw with MAXIMUM quality settings
                            ctx.save();
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';
                            ctx.drawImage(img, destX, destY, destW, destH);
                            ctx.restore();
                            return true;
                        }
                        return false;
                    }).catch(err => {
                        console.warn(`Failed to load tile ${tileX},${tileY}:`, err.message);
                        return false;
                    });
                    
                    tilePromises.push(promise);
                }
            }
            
            // Wait for all tiles to load
            const results = await Promise.all(tilePromises);
            const successCount = results.filter(r => r).length;
            const successRate = (successCount / totalTiles * 100).toFixed(1);
            console.log(`‚úÖ Loaded ${successCount}/${totalTiles} tiles (${successRate}%)`);
            
            if (successCount === 0) {
                throw new Error('Failed to load any imagery tiles. Check internet connection.');
            }
            
            // Convert to blob with MAXIMUM quality (99% - absolute highest)
            imageryBlob = await new Promise(resolve => {
                canvas.toBlob(blob => resolve(blob), 'image/jpeg', 0.99); // 99% MAXIMUM quality
            });
            
            const sizeMB = (imageryBlob.size / 1024 / 1024).toFixed(2);
            console.log(`‚úÖ ULTRA HIGH QUALITY satellite imagery: ${sizeMB} MB at ${canvasWidth}x${canvasHeight} (${successRate}% coverage)`);
        }
        
        function tileToQuadKey(x, y, z) {
            let quadKey = '';
            for (let i = z; i > 0; i--) {
                let digit = 0;
                const mask = 1 << (i - 1);
                if ((x & mask) !== 0) digit++;
                if ((y & mask) !== 0) digit += 2;
                quadKey += digit.toString();
            }
            return quadKey;
        }
        
        function loadTileImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                const timeout = setTimeout(() => {
                    reject(new Error('Timeout'));
                }, 10000); // 10 second timeout
                
                img.onload = () => {
                    clearTimeout(timeout);
                    resolve(img);
                };
                
                img.onerror = () => {
                    clearTimeout(timeout);
                    reject(new Error('Failed to load'));
                };
                
                img.src = url;
            });
        }

        // Initialize 3D viewer
        function init3DViewer() {
            const container = document.getElementById('viewer3d');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            camera = new THREE.PerspectiveCamera(60, width / height, 1, 10000);
            camera.position.set(800, 800, 800);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            
            const infoOverlay = container.querySelector('.info-overlay');
            container.insertBefore(renderer.domElement, infoOverlay);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(200, 300, 200);
            scene.add(directionalLight);

            const gridHelper = new THREE.GridHelper(2000, 20, 0x00ff00, 0x444444);
            scene.add(gridHelper);

            if (terrainData) createTerrainMesh();

            setupMouseControls();
            animate();
            
            document.getElementById('viewer3dInfo').innerHTML = `
                <h3>‚úÖ Terrain Loaded</h3>
                <p><strong>Source:</strong> ${terrainData.source}</p>
                <p>Drag to rotate ‚Ä¢ Right-drag to pan ‚Ä¢ Scroll to zoom</p>
            `;
        }

        function createTerrainMesh() {
            const resolution = terrainData.resolution;
            
            // Check if vertical exaggeration is enabled
            const vExagEnabled = document.getElementById('enableVExag').checked;
            const vExag = vExagEnabled ? parseFloat(document.getElementById('vExag').value) : 1.0;
            
            const avgElev = (terrainData.minElevation + terrainData.maxElevation) / 2;
            
            const geometry = new THREE.PlaneGeometry(1000, 1000, resolution - 1, resolution - 1);
            const vertices = geometry.attributes.position.array;
            
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const idx = (i * resolution + j) * 3;
                    const elevation = terrainData.grid[i][j];
                    vertices[idx + 2] = (elevation - avgElev) * vExag;
                }
            }
            
            geometry.computeVertexNormals();
            geometry.attributes.position.needsUpdate = true;

            // Create material - use texture if available
            let material;
            if (imageryBlob) {
                // Load texture from blob
                const textureLoader = new THREE.TextureLoader();
                const blobUrl = URL.createObjectURL(imageryBlob);
                const texture = textureLoader.load(blobUrl, () => {
                    // Cleanup blob URL after texture loads
                    URL.revokeObjectURL(blobUrl);
                });
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                
                material = new THREE.MeshLambertMaterial({
                    map: texture,
                    side: THREE.DoubleSide
                });
            } else {
                // Fallback to solid color
                material = new THREE.MeshLambertMaterial({
                    color: 0x7cb342,
                    wireframe: false
                });
            }

            if (terrainMesh) scene.remove(terrainMesh);
            
            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.rotation.x = -Math.PI / 2;
            scene.add(terrainMesh);
        }

        function setupMouseControls() {
            let isDragging = false, isRightDrag = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', e => {
                isDragging = true;
                isRightDrag = e.button === 2;
                previousMousePosition = { x: e.clientX, y: e.clientY };
                e.preventDefault();
            });
            
            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
            
            renderer.domElement.addEventListener('mousemove', e => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                if (isRightDrag) {
                    camera.position.x -= deltaX * 2;
                    camera.position.z -= deltaY * 2;
                } else {
                    const rotateSpeed = 0.005;
                    const radius = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
                    const theta = Math.atan2(camera.position.x, camera.position.z);
                    const newTheta = theta + deltaX * rotateSpeed;
                    
                    camera.position.x = radius * Math.sin(newTheta);
                    camera.position.z = radius * Math.cos(newTheta);
                    camera.position.y += deltaY * 2;
                    camera.lookAt(0, 0, 0);
                }
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
                isRightDrag = false;
            });

            renderer.domElement.addEventListener('wheel', e => {
                e.preventDefault();
                camera.position.multiplyScalar(e.deltaY > 0 ? 1.1 : 0.9);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Reset camera
        document.getElementById('resetCameraBtn').addEventListener('click', () => {
            camera.position.set(800, 800, 800);
            camera.lookAt(0, 0, 0);
        });

        // Vertical exaggeration toggle
        document.getElementById('enableVExag').addEventListener('change', function() {
            const vExagControls = document.getElementById('vExagControls');
            const vExagSlider = document.getElementById('vExag');
            
            if (this.checked) {
                // Enable vertical exaggeration
                vExagControls.style.opacity = '1';
                vExagControls.style.pointerEvents = 'auto';
                vExagSlider.disabled = false;
            } else {
                // Disable and reset to 1:1 scale
                vExagControls.style.opacity = '0.5';
                vExagControls.style.pointerEvents = 'none';
                vExagSlider.disabled = true;
                vExagSlider.value = '1';
                document.getElementById('vExagValue').textContent = '1.0';
                if (terrainMesh) createTerrainMesh();
            }
        });

        // Vertical exaggeration slider
        document.getElementById('vExag').addEventListener('input', function() {
            document.getElementById('vExagValue').textContent = parseFloat(this.value).toFixed(1);
            if (terrainMesh) createTerrainMesh();
        });

        function updateTerrainStats() {
            const centerLat = ((bounds.getSouth() + bounds.getNorth()) / 2).toFixed(5);
            const centerLon = ((bounds.getWest() + bounds.getEast()) / 2).toFixed(5);

            let imageryInfo = '';
            if (imageryBlob) {
                const sizeMB = (imageryBlob.size / 1024 / 1024).toFixed(2);
                imageryInfo = `
                    <div class="terrain-info-item">
                        <span class="terrain-info-label">Satellite Imagery</span>
                        <span class="terrain-info-value">‚úÖ ${sizeMB} MB</span>
                    </div>
                `;
            }

            document.getElementById('terrainStats').innerHTML = `
                <div class="terrain-info">
                    <div class="terrain-info-item">
                        <span class="terrain-info-label">Location</span>
                        <span class="terrain-info-value" style="font-size: 11px;">${centerLat}¬∞, ${centerLon}¬∞</span>
                    </div>
                    <div class="terrain-info-item">
                        <span class="terrain-info-label">Elevation Range</span>
                        <span class="terrain-info-value">${terrainData.minElevation.toFixed(0)}' - ${terrainData.maxElevation.toFixed(0)}'</span>
                    </div>
                    <div class="terrain-info-item">
                        <span class="terrain-info-label">Resolution</span>
                        <span class="terrain-info-value">${terrainData.resolution}√ó${terrainData.resolution}</span>
                    </div>
                    ${imageryInfo}
                </div>
            `;
        }

        // Export functions
        document.getElementById('exportOBJ').addEventListener('click', () => exportOBJWithTexture());
        document.getElementById('exportFBX').addEventListener('click', () => exportFBX());
        document.getElementById('exportDXF').addEventListener('click', () => exportSimple('DXF'));
        document.getElementById('exportCSV').addEventListener('click', () => exportSimple('CSV'));
        document.getElementById('exportJSON').addEventListener('click', () => exportSimple('JSON'));

        function exportOBJWithTexture() {
            const messageDiv = document.getElementById('exportMessage');
            const includeTexture = document.getElementById('includeImageryOBJ').checked;
            
            messageDiv.innerHTML = '<div class="message info">Generating OBJ with correct coordinates (Y-forward, Z-up)...</div>';
            
            setTimeout(() => {
                const data = terrainData;
                const res = data.resolution;
                
                // Check if vertical exaggeration is enabled
                const vExagEnabled = document.getElementById('enableVExag').checked;
                const vExag = vExagEnabled ? parseFloat(document.getElementById('vExag').value) : 1.0;
                
                const avgElev = (data.minElevation + data.maxElevation) / 2;

                // Create consistent timestamp for all files
                const timestamp = Date.now();
                const baseName = `terrain_${timestamp}`;
                const mtlFileName = `${baseName}.mtl`;
                const textureFileName = `${baseName}_texture.jpg`;

                // OBJ file - Y-forward, Z-up (SketchUp standard)
                let obj = '# VDC Terrain Export - Professional Survey Grade\n';
                obj += '# Coordinate System: Y-forward, Z-up (SketchUp standard)\n';
                obj += `# State Plane: EPSG:${data.statePlane}\n`;
                obj += `# Elevation Range: ${data.minElevation.toFixed(2)}' - ${data.maxElevation.toFixed(2)}'\n`;
                obj += `# Elevation Grid: ${res}√ó${res} points (${(res * res).toLocaleString()} samples)\n`;
                obj += `# Vertical Scale: ${vExag.toFixed(2)}x ${vExagEnabled ? '(Exaggerated)' : '(True 1:1)'}\n`;
                if (includeTexture && imageryBlob) {
                    obj += `# Texture Resolution: 8192√ó8192 pixels (Ultra HD)\n`;
                    obj += `# Texture Quality: 99% JPEG (Survey Grade)\n`;
                    obj += `# Texture Size: ${(imageryBlob.size / 1024 / 1024).toFixed(2)} MB\n`;
                }
                obj += `# Source: ${data.source}\n`;
                obj += `# Generated: ${new Date().toISOString()}\n`;
                if (includeTexture) obj += `mtllib ${mtlFileName}\n`;
                obj += '\n';

                // Vertices with corrected axes
                for (let i = 0; i < res; i++) {
                    for (let j = 0; j < res; j++) {
                        const x = (j / res) * 1000 - 500;
                        const y = (i / res) * 1000 - 500; // Y-forward
                        const z = (data.grid[i][j] - avgElev) * vExag; // Z-up
                        obj += `v ${x.toFixed(2)} ${y.toFixed(2)} ${z.toFixed(2)}\n`;
                    }
                }

                // Texture coordinates (properly oriented)
                if (includeTexture) {
                    obj += '\n';
                    for (let i = 0; i < res; i++) {
                        for (let j = 0; j < res; j++) {
                            const u = j / (res - 1);
                            const v = 1 - (i / (res - 1)); // Flip V for proper texture orientation
                            obj += `vt ${u.toFixed(4)} ${v.toFixed(4)}\n`;
                        }
                    }
                }

                // Faces with texture coords
                obj += '\n';
                if (includeTexture) obj += 'usemtl terrain_material\n';
                
                for (let i = 0; i < res - 1; i++) {
                    for (let j = 0; j < res - 1; j++) {
                        const v1 = i * res + j + 1;
                        const v2 = v1 + 1;
                        const v3 = v1 + res;
                        const v4 = v3 + 1;
                        
                        if (includeTexture) {
                            obj += `f ${v1}/${v1} ${v2}/${v2} ${v4}/${v4}\n`;
                            obj += `f ${v1}/${v1} ${v4}/${v4} ${v3}/${v3}\n`;
                        } else {
                            obj += `f ${v1} ${v2} ${v4}\n`;
                            obj += `f ${v1} ${v4} ${v3}\n`;
                        }
                    }
                }

                // Download OBJ
                downloadFile(obj, `${baseName}.obj`, 'text/plain');

                // Create and download MTL file
                if (includeTexture) {
                    const mtl = `# VDC Terrain Material - Professional Survey Grade
# Ultra HD Satellite Imagery Texture
# Resolution: 8192√ó8192 pixels
# Quality: 99% JPEG compression
# Generated: ${new Date().toISOString()}

newmtl terrain_material
Ka 1.000 1.000 1.000
Kd 1.000 1.000 1.000
Ks 0.000 0.000 0.000
Ns 10.0
illum 2
map_Kd ${textureFileName}
`;
                    downloadFile(mtl, mtlFileName, 'text/plain');
                    
                    // Download texture image
                    if (imageryBlob) {
                        const url = URL.createObjectURL(imageryBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = textureFileName;
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        const textureSizeMB = (imageryBlob.size / 1024 / 1024).toFixed(2);
                        messageDiv.innerHTML = `<div class="message success">‚úÖ ULTRA HD Export Complete!<br>
                            <small>OBJ + MTL + 8192√ó8192 texture (${textureSizeMB} MB)<br>
                            Import all 3 files into SketchUp for survey-grade quality</small></div>`;
                    } else {
                        messageDiv.innerHTML = '<div class="message error">‚ö†Ô∏è OBJ exported but texture unavailable</div>';
                    }
                } else {
                    messageDiv.innerHTML = '<div class="message success">‚úÖ OBJ exported (no texture)</div>';
                }
                
                setTimeout(() => messageDiv.innerHTML = '', 5000);
            }, 500);
        }

        function exportFBX() {
            const messageDiv = document.getElementById('exportMessage');
            messageDiv.innerHTML = '<div class="message info">FBX export with embedded texture coming soon...</div>';
            
            setTimeout(() => {
                messageDiv.innerHTML = '<div class="message info">üí° For now, use OBJ+MTL and convert to FBX in Blender/3ds Max with textures embedded.</div>';
            }, 2000);
        }

        function exportSimple(format) {
            const messageDiv = document.getElementById('exportMessage');
            messageDiv.innerHTML = `<div class="message info">Generating ${format}...</div>`;
            
            setTimeout(() => {
                let content = '';
                let filename = `terrain_${Date.now()}.`;
                
                if (format === 'CSV') {
                    content = 'X,Y,Z,Elevation\n';
                    const res = terrainData.resolution;
                    for (let i = 0; i < res; i += 2) {
                        for (let j = 0; j < res; j += 2) {
                            const x = (j / res) * 1000;
                            const y = (i / res) * 1000;
                            const z = terrainData.grid[i][j];
                            content += `${x.toFixed(2)},${y.toFixed(2)},${z.toFixed(2)},${z.toFixed(2)}\n`;
                        }
                    }
                    filename += 'csv';
                } else if (format === 'JSON') {
                    content = JSON.stringify(terrainData, null, 2);
                    filename += 'json';
                }
                
                downloadFile(content, filename, 'text/plain');
                messageDiv.innerHTML = `<div class="message success">‚úÖ ${format} exported!</div>`;
                setTimeout(() => messageDiv.innerHTML = '', 3000);
            }, 500);
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], {type: type});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        window.addEventListener('resize', () => {
            if (renderer && camera) {
                const container = document.getElementById('viewer3d');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
    </script>
</body>
</html>